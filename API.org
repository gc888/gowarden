* Bitwarden API Overview

[[https://github.com/jcs/rubywarden/blob/master/API.md][原文]]

尽管开源了，但是 [[https://github.com/bitwarden/core][.NET Bitwarden API code ]]依然很难从较高的层次游览与理解，也没有相应的 API endpoints 文档来描述加密解密是如何实现的。

以下的笔记是通过运行 [[https://github.com/jcs/rubywarden/blob/master/tools/mitm.rb][mitm]] 并用 ~http://127.0.0.1:4567/~ 为URL来跟踪与分析 Firefox 插件与 Bitwarden 服务端的通信得到的。

关于密匙与加密/解密的详细信息是通过阅读 [[https://github.com/bitwarden/browser][web插件]] 得到的。

** 密码的hash与加密密匙的推导

概括：

  - [[https://en.wikipedia.org/wiki/PBKDF2][PBKDF2]] 与 ~$KdfIterations~ 使用用户的 master key 与加了盐的 email 地址来生成 master key(服务器端未知)。
  - 使用64个随机的字节作为对称密匙，前一半用来做加密密匙，后一半作为 MAC 密匙。
  - 使用 AES-256-CBC 将 master key 与16字节的IV加密对称密匙，“输出+IV”变成“受保护的对称密匙”添加到用户的账户中，存储在服务器
    端并在同步时发送到 Bitwarden 的客户端应用。
  - 存储的每个字符串的私有值都会被对称密匙进行加密(成为 "Cipher" obejects)，只能通过用户的受保护的对称密匙与 master key才
    能解密。

改变用户的密码或 email 会创建一个新的 master key，然后用已经存在的对称密匙重新加密，再创建一个新的受保护密匙，这样就可以解密
所有已经存在的 Cipher object 字符串。

*例子*

假设用户输入的 ~$masterPassword~ 是 ~p4ssw0rd~, ~$email~ 是 ~nobody@example.com~

PBKDF2 is used with a password of $masterPassword, salt of lowercased $email, and $iterations KDF iterations to stretch password into $masterKey.

#+BEGIN_SRC ruby
def makeKey(password, salt, iterations)
  PBKDF2.new(:password => password, :salt => salt,
    :iterations => iterations, :hash_function => OpenSSL::Digest::SHA256,
    :key_length => (256 / 8)).bin_string
end

irb> $masterKey = makeKey("p4ssw0rd", "nobody@example.com".downcase, 5000)
=> "\x13\x88j`\x99m\xE3FA\x94\xEE'\xF0\xB2\x1A!\xB6>\\)\xF4\xD5\xCA#\xE5\e\xA6f5o{\xAA"
#+END_SRC

这样创建了一个随机的，64位的对称密匙 ~$symmetricKey~ 。前32位作为 ~$encKey~ ，后32位作为 ~$macKey~ 。 同时也创建了一个随机的
16字节 IV ~$iv~ ， 而 ~$masterKey~ 则被用来作为加密 ~$symmetricKey~ 的密匙。

通过使用 [[https://github.com/bitwarden/browser/blob/f1262147a33f302b5e569f13f56739f05bbec362/src/services/constantsService.js#L13-L21][encryption type]] (~0~ 代表 ~AesCbc256_B64~) 经过Base64编码的 IV、 ~$encKey~ 与 ~$macKey~ 与竖线(~|~)结合在一起创建
"CipherString" (一种Bitwarden的内部结构)作为 ~$protectedKey~ 。

#+BEGIN_SRC ruby
def cipherString(enctype, iv, ct, mac)
  [ enctype.to_s + "." + iv, ct, mac ].reject{|p| !p }.join("|")
end

# encrypt random bytes with a key to make new encryption key
def makeEncKey(key)
  # pt[0, 32] becomes the cipher encryption key
  # pt[32, 32] becomes the mac key
  pt = OpenSSL::Random.random_bytes(64)
  iv = OpenSSL::Random.random_bytes(16)

  cipher = OpenSSL::Cipher.new "AES-256-CBC"
  cipher.encrypt
  cipher.key = key
  cipher.iv = iv
  ct = cipher.update(pt)
  ct << cipher.final

  return cipherString(0, Base64.strict_encode64(iv), Base64.strict_encode64(ct), nil)
end

irb> $protectedKey = makeEncKey($masterKey)
=> "0.uRcMe+Mc2nmOet4yWx9BwA==|PGQhpYUlTUq/vBEDj1KOHVMlTIH1eecMl0j80+Zu0VRVfFa7X/MWKdVM6OM/NfSZicFEwaLWqpyBlOrBXhR+trkX/dPRnfwJD2B93hnLNGQ="
#+END_SRC

这就是与用户相关的主密匙并会在账户创建后发送到服务器，并在同步后发送回设备。

在账户创建与登录时一个扩展密码的hash值 ~$masterPasswordHash~ 也会发送到服务器用来验证用户的账户。这个hash值是通过将
~$masterKey~ (使用(~$masterPassword~, ~$email~)进行5000次PBKDF2加密得到) 与 ~masterPassword~ 的盐进行一轮 PBKDF2 得到的。

#+BEGIN_SRC  ruby
# base64-encode a wrapped, stretched password+salt for signup/login
def hashedPassword(password, salt, kdf_iterations)
  key = makeKey(password, salt, kdf_iterations)
  Base64.strict_encode64(PBKDF2.new(:password => key, :salt => password,
    :iterations => 1, :key_length => 256/8,
    :hash_function => OpenSSL::Digest::SHA256).bin_string)
end

irb> $masterPasswordHash = hashedPassword("p4ssw0rd", "nobody@example.com", 5000)
=> "r5CFRR+n9NQI8a525FY+0BPR0HGOjVJX0cR1KEMnIOo="
#+END_SRC

之后，登录时就可以使用用户文本形式的 ~$masterPassword~ 和 ~$email~ 计算出 ~$masterKey~ 然后将 ~$masterPassword~ 从内存中
清除。使用 ~$masterKey~ 为服务器返回的 ~$protectedKey~ 解密，使用 ~$encKey~ 与 ~$macKey~ 为每一条内容加密。 ~$masterPassword~ 
与 ~$masterKey~ 应该永远留在设备中。

** "Cipher" 的加密与解密

Bitwarden将每个点都视为 "cipher" 类型(例如网站登录、安全笔记、信用卡等等)，这个 [[https://github.com/bitwarden/browser/blob/f1262147a33f302b5e569f13f56739f05bbec362/src/services/constantsService.js#L22-L27][type]] 的值要表明它是什么。每个 cipher 都有
许多键/值对，其中某些值是被加密的：

#+BEGIN_SRC  json
{
	"type": 1,
	"folderId": null,
	"organizationId": null,
	"name":"2.zAgCKbTvGowtaRn1er5WGA==|oVaVLIjfBQoRr5EvHTwfhQ==|lHSTUO5Rgfkjl3J/zGJVRfL8Ab5XrepmyMv9iZL5JBE=",
	"notes":"2.NLkXMHtgR8u9azASR4XPOQ==|6/9QPcnoeQJDKBZTjcBAjVYJ7U/ArTch0hUSHZns6v8=|p55cl9FQK/Hef+7yzM7Cfe0w07q5hZI9tTbxupZepyM=",
	"favorite": false,
	"login": {
		"uris": [
			{
				"uri": "2.6DmdNKlm3a+9k/5DFg+pTg==|7q1Arwz/ZfKEx+fksV3yo0HMQdypHJvyiix6hzgF3gY=|7lSXqjfq5rD3/3ofNZVpgv1ags696B2XXJryiGjDZvk=",
				"match": null
			}
		],
		"username": "2.4Dwitdv4Br85MABzhMJ4hg==|0BJtHtXbfZWwQXbFcBn0aA==|LM4VC+qNpezmub1f4l1TMLDb9g/Q+sIis2vDbU32ZGA=",
		"password": "2.OOlWRBGib6G8WRvBOziKzQ==|Had/obAdd2/6y4qzM1Kc/A==|LtHXwZc5PkiReFhkzvEHIL01NrsWGvintQbmqwxoXSI=",
		"totp": null
	}
}
#+END_SRC

其中 ~name~ , ~notes~ , ~login.uris[0].uri~ , ~login.username~ 和 ~login.password~ 的值都是被作为 "CipherString" 进行
加密后的，前面的 ~2~ 代表它的类型(~AesCbc256_HmacSha255_B64~)。

想要解密其值，需先将 CipherString 分解为 IV, cipher text 和 MAC，再将各个部分进行Base64解码。使用 ~$macKey~ 可以计算出
MAC，并将其与当前的MAC对比，如果相等，则使用 ~$encKey~ 将 cipher text 解码。

#+BEGIN_SRC  ruby
# compare two hmacs, with double hmac verification
# https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/february/double-hmac-verification/
def macsEqual(macKey, mac1, mac2)
  hmac1 = OpenSSL::HMAC.digest(OpenSSL::Digest.new("SHA256"), macKey, mac1)
  hmac2 = OpenSSL::HMAC.digest(OpenSSL::Digest.new("SHA256"), macKey, mac2)
  return hmac1 == hmac2
end

# decrypt a CipherString and return plaintext
def decrypt(str, key, macKey)
  if str[0].to_i != 2
    raise "implement #{str[0].to_i} decryption"
  end

  # AesCbc256_HmacSha256_B64
  iv, ct, mac = str[2 .. -1].split("|", 3)

  iv = Base64.decode64(iv)
  ct = Base64.decode64(ct)
  mac = Base64.decode64(mac)

  cmac = OpenSSL::HMAC.digest(OpenSSL::Digest.new("SHA256"), macKey, iv + ct)
  if !macsEqual(macKey, mac, cmac)
    raise "invalid mac"
  end

  cipher = OpenSSL::Cipher.new "AES-256-CBC"
  cipher.decrypt
  cipher.iv = iv
  cipher.key = key
  pt = cipher.update(ct)
  pt << cipher.final
  pt
end

irb> decrypt("2.6DmdNKlm3a+9k/5DFg+pTg==|7q1Arwz/ZfKEx+fksV3yo0HMQdypHJvyiix6hzgF3gY=|7lSXqjfq5rD3/3ofNZVpgv1ags696B2XXJryiGjDZvk=", $encKey, $macKey)
=> "https://example.com/login"
#+END_SRC

在生成了随机的16字节 IV ~$iv~ ，使用 ~$encKey~ 将文本加密为 ~$cipherText~ 后加密的工作就结束了。MAC ~$mac~ 则是通过(~$iv + $cipherText~)
计算得来的。其中 ~$iv~, ~$cipherText~, 与 ~$mac~ 都是经过Base64编码并使用竖线(~|~)连接在一起，然后在字符串的开头增加类型(~2.~)从
而生成一个 CipherString。

#+BEGIN_SRC  ruby
# encrypt+mac a value with a key and mac key and random iv, return cipherString
def encrypt(pt, key, macKey)
  iv = OpenSSL::Random.random_bytes(16)

  cipher = OpenSSL::Cipher.new "AES-256-CBC"
  cipher.encrypt
  cipher.key = key
  cipher.iv = iv
  ct = cipher.update(pt)
  ct << cipher.final

  mac = OpenSSL::HMAC.digest(OpenSSL::Digest.new("SHA256"), macKey, iv + ct)

  cipherString(2, Base64.strict_encode64(iv), Base64.strict_encode64(ct), Base64.strict_encode64(mac))
end

irb> encrypt("A secret note here...", $encKey, $macKey)
=> "2.NLkXMHtgR8u9azASR4XPOQ==|6/9QPcnoeQJDKBZTjcBAjVYJ7U/ArTch0hUSHZns6v8=|p55cl9FQK/Hef+7yzM7Cfe0w07q5hZI9tTbxupZepyM="
#+END_SRC


** API
-----
*** URLs

 默认情况下，Bitwardens使用 ~$bitwarden.com~ 的三个不同的子域名，其中 ~$baseURL~ 进行最多的 API 操作， ~$identityURL~
 处理登录(由于某种原因没有注册的情况下)和一些第三方(OAuth tokens)的问题， ~$iconURL~ 则只处理抓取，缓存与请求网站图标的
 服务。

 如果在app中登录之前配置了自己架设的服务环境时，则这三个都会被设置为相同的URL。

*** 注册

在拿到 e-mail 地址与用户 master password之后使用它们计算出 ~$internalKey~, ~$masterPasswordHash~ 和 ~$key~ (皆为 CipherString)。

#+BEGIN_SRC ruby
irb> $internalKey = makeKey("p4ssw0rd", "nobody@example.com".downcase, 5000)
=> "\x13\x88j`\x99m\xE3FA\x94\xEE'\xF0\xB2\x1A!\xB6>\\)\xF4\xD5\xCA#\xE5\e\xA6f5o{\xAA"

irb> $masterPasswordHash = hashedPassword("p4ssw0rd", "nobody@example.com", 5000)
=> "r5CFRR+n9NQI8a525FY+0BPR0HGOjVJX0cR1KEMnIOo="

irb> $key = makeEncKey($internalKey)
=> "0.uRcMe+Mc2nmOet4yWx9BwA==|PGQhpYUlTUq/vBEDj1KOHVMlTIH1eecMl0j80+Zu0VRVfFa7X/MWKdVM6OM/NfSZicFEwaLWqpyBlOrBXhR+trkX/dPRnfwJD2B93hnLNGQ="
#+END_SRC

内存中的 ~$masterPassword~ 应被安全的移除，因为知道下一次登录之前都不需要使用它了。

向 ~$baseURL/accounts/register~ 提交一个 ~POST~ 请求，请求体十一个包含 e-mail 地址, ~$masterPasswordHash~ , KDF的
迭代次数 ~$kdfIterations~ , 和一个 ~$key~ (不是 ~$internalKey~ !!!):

#+BEGIN_SRC  json
POST $baseURL/accounts/register
Content-type: application/json

{
	"name": null,
	"email": "nobody@example.com",
	"masterPasswordHash": "r5CFRR+n9NQI8a525FY+0BPR0HGOjVJX0cR1KEMnIOo=",
	"masterPasswordHint": null,
	"key": "0.uRcMe+Mc2nmOet4yWx9BwA==|PGQhpYUlTUq/vBEDj1KOHVMlTIH1eecMl0j80+Zu0VRVfFa7X/MWKdVM6OM/NfSZicFEwaLWqpyBlOrBXhR+trkX/dPRnfwJD2B93hnLNGQ=",
	"kdf": 0,
	"kdfIterations": 5000,
}
#+END_SRC
 
 相应应为 ~200~ 和一个空的相应体。
*** 登录
 
